SHELL := /bin/bash

# General variables
IMAGE_NAME := orchestra
TAG := latest
DOCKER_USERNAME := skhan61
FULL_IMAGE_NAME := $(DOCKER_USERNAME)/$(IMAGE_NAME):$(TAG)
# Git-crypt tasks
REPO_DIR := $(shell git rev-parse --show-toplevel)
KEY_FILE := $(REPO_DIR)/.git/git-crypt/keys/default

# Helpers
.PHONY: help clean clean-logs format sync test test-full train commit-push push-no-verify build-docker push-docker delete-docker update-and-push-docker build run shell

# Show help
help:
	@grep -E '^[.a-zA-Z_-]+:.*?## .*$$' $(MAKEFILE_LIST) | awk 'BEGIN {FS = ":.*?## "}; {printf "\033[36m%-30s\033[0m %s\n", $$1, $$2}'

clear:
	@clear

clean: ## Clean autogenerated files
	rm -rf dist || echo "dist directory does not exist"
	find . -type f -name "*.DS_Store" -delete
	find . -type d -name "__pycache__" -exec rm -rf {} + || true
	find . -type f \( -name "*.pyc" -o -name "*.pyo" \) -delete
	find . -type d -name ".pytest_cache" -exec rm -rf {} + || true
	find . -type d -name ".ipynb_checkpoints" -exec rm -rf {} + || true
	find . -type d -name ".mypy_cache" -exec rm -rf {} + || true
	find . -type d -name ".tox" -exec rm -rf {} + || true
	find . -type d -name ".eggs" -exec rm -rf {} + || true
	rm -rf .cache .coverage build *.egg-info || echo "Nothing to clean."

clean-logs: ## Clean logs
	rm -rf logs/** || echo "No logs to clean."

# Development tasks
format: ## Run pre-commit hooks
	pre-commit run -a || echo "Pre-commit hooks failed. Please fix issues."

sync: ## Sync changes from main branch
	git stash push -m "WIP: Save changes before sync" || echo "No changes to stash."
	git pull --rebase origin main || echo "Failed to rebase from main."
	git stash pop || echo "No stashed changes to apply."

reset-main: ## Reset local main branch to match remote main branch exactly
	git fetch origin main
	git reset --hard origin/main
	git clean -fd

test: ## Run not slow tests
	pytest -k "not slow" || echo "Some tests failed."

test-full: ## Run all tests
	pytest || echo "Some tests failed."

test-api-1000: ## Run offline API smoke-test on 1000 words
	conda run -n orchestra python -m api.test --limit 1000 || echo "API test failed."

train: ## Train the model
	python src/train.py || echo "Training script failed."

commit-push: ## Commit and push changes with a provided commit message
	if [ -z "$(m)" ]; then echo "Usage: make commit-push m='Your commit message'"; else \
	git add . && git commit -m "$(m)" && git push || echo "Commit or push failed."; \
	fi

push-no-verify: ## Push changes without pre-push hooks # locally
	if [ -z "$(m)" ]; then echo "Usage: make push-no-verify m='Your commit message'"; else \
	git add . && git commit -m "$(m)" && git push --no-verify || echo "Commit or push failed."; \
	fi

# push-no-ci: ## Push changes without running tests or CI # github actions
# 	if [ -z "$(m)" ]; then echo "Usage: make push-no-ci m='Your commit message'"; else \
# 	git add . && git commit -m "$(m) [skip ci]" && git push --no-verify || echo "Commit or push failed."; \
# 	fi

# push-no-ci:
# 	if [ -z "$(m)" ]; then \
# 		echo "Usage: make push-no-ci m='Your commit message'"; \
# 	else \
# 		set -x; \
# 		git add . && git commit -m "$(m) [skip ci]"; \
# 		git submodule update --recursive --remote; \
# 		git submodule foreach --recursive 'git add . && git commit -m "$(m) [skip ci]" || echo "No changes in submodule to commit"'; \
# 		git submodule foreach --recursive 'git push --no-verify || echo "Submodule push failed."'; \
# 		git push --no-verify || echo "Commit or push failed."; \
# 	fi

push-no-ci:
	if [ -z "$(m)" ]; then \
		echo "Usage: make push-no-ci m='Your commit message'"; \
	else \
		set -x; \
		git add . && git commit -m "$(m) [skip ci]"; \
		git submodule update --recursive --remote; \
		git submodule foreach --recursive 'git add . && git commit -m "$(m) [skip ci]" || echo "No changes in submodule to commit"'; \
		git submodule foreach --recursive 'git push --no-verify || echo "Submodule push failed."'; \
		git add symphony && git commit -m "Update submodule pointer [skip ci]" || echo "No submodule pointer update"; \
		git push --no-verify || echo "Commit or push failed."; \
	fi



# Docker tasks
see-docker-containers: ## List all Docker images
	docker images || echo "Failed to list Docker images."

build-docker: ## Build the Docker image
	docker build -t $(FULL_IMAGE_NAME) . || echo "Docker build failed."

push-docker: ## Push the Docker image to Docker Hub
	docker push $(FULL_IMAGE_NAME) || echo "Docker push failed."

delete-docker: ## Delete the Docker image
	sudo docker rmi $(FULL_IMAGE_NAME) || echo "Failed to delete Docker image."

update-and-push-docker: build-docker push-docker ## Update requirements.txt, rebuild, and push the Docker image

# Run the application using Docker volumes
docker-run-main: ## Run the application with local changes
	sudo docker run -it --rm -p 4000:4000 -v "$(PWD):/app" $(FULL_IMAGE_NAME) python /app/main.py || echo "Docker run failed."

# Run tests in Docker
build-docker-run-tests: build-docker ## Build the Docker image and run tests
	sudo docker run -it --rm -v "$(PWD):/app" $(FULL_IMAGE_NAME) pytest -v /app/tests/ || echo "Docker tests failed."

docker-run-tests: ## Check if Docker image exists locally, pull if not, and run tests
	@if [ -z "$$(sudo docker images -q $(FULL_IMAGE_NAME))" ]; then \
		echo "Image $(FULL_IMAGE_NAME) not found locally. Pulling..."; \
		sudo docker pull $(FULL_IMAGE_NAME) || { echo "Failed to pull Docker image."; exit 1; }; \
	fi
	@echo "Running tests using $(FULL_IMAGE_NAME)..."
	sudo docker run -it --rm -v "$(PWD):/app" $(FULL_IMAGE_NAME) pytest -v -s /app/tests/ || echo "Docker tests failed."

docker-shell: ## Run a shell inside the Docker image
	sudo docker run -it --rm -v "$(PWD):/app" $(FULL_IMAGE_NAME) /bin/bash || echo "Failed to start Docker shell."

build-and-push-docker: build-docker push-docker ## Build and push the Docker image

run:
	python main.py || echo "Application failed to run."

## .env encryption

ask-password:
	@mkdir -p $(REPO_DIR)/.git/git-crypt/keys/
	@echo "Enter the encryption password: "
	@read -s PASSWORD; \
	echo $$PASSWORD | openssl enc -aes-256-cbc -md sha256 -pbkdf2 -pass stdin -nosalt -base64 -P | grep key | sed 's/key=//' > $(KEY_FILE) || { echo "Failed to generate encryption key."; exit 1; }
	@echo "Key generated and stored in $(KEY_FILE)."

init-git-crypt: ask-password
	@cd $(REPO_DIR) && git-crypt init || echo "Failed to initialize git-crypt."

encrypt-files:
	@cd $(REPO_DIR) && git add .gitattributes && git commit -m "Configure git-crypt for specified files." || echo "Failed to configure git-crypt encryption."

secure-commit-push:
	@cd $(REPO_DIR) && git add -A && git commit -m "Secure commit with git-crypt." && git push || echo "Failed to commit or push changes."

encrypt-commit-push: init-git-crypt encrypt-files secure-commit-push
	@echo "Encryption setup, commit, and push operations complete."

clone-and-unlock:
	@echo "Cloning the current repository..."
	@GIT_REPO_URL=$$(git config --get remote.origin.url); \
	if [ -z "$$GIT_REPO_URL" ]; then \
		echo "Error: Unable to determine the repository URL."; \
		exit 1; \
	fi; \
	git clone $$GIT_REPO_URL $(REPO_DIR) || { echo "Failed to clone repository."; exit 1; }; \
	$(MAKE) unlock-repo || { echo "Failed to unlock repository."; exit 1; }
